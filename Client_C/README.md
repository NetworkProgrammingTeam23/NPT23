# 스레드 기반의 클라이언트
사용언어 : C<br>
통신 대상 언어 : Python
## 해결해야 하는 점
1. 메세지 정의
2. ~~공유 자원 문제 해결~~
	생각해보니 에코 서버가 아님
3. ~~읽기 스레드만 동작하는 문제~~
	반복문 수정으로 해결
4. ~~멀티 상황에서 테스트할 서버 부재 (만드는 중)~~
	만들어짐
5. ~~recv는 반드시 한 번에 이루어진다는 보장이 없음~~
	파이썬은 잘 되는 것 같지만, c에서 recv()해서 buf에 내용을 저장해도 여러 번에 걸쳐 메세지가 도착하는 문제 발생, 추후 논의 필요
6. ~~recv()로 받아오면 점차 문장이 짤려서 옴~~
	5번과 연관된 문제같음. recv 이후 buf에 저장된 데이터를 print해줄 때 printf("%s\n", buf);를 하면 지멋대로 끊어서 바이트를 가져와서 글도 ?로 일관되게 깨지고 난리도 아님
	+) 어느 시점부터 recv가 제대로 작동하지 않는 듯함.
7. msg = '[{}] {} : {}'.format(time.strftime('%X'), user_list[sock][0], recvData.decode('euc-kr'))에서 recvData.decode('euc-kr')만 못받음
	5, 6번을 해결하니 새로운 문제 발생. 5, 6번보다 확실하고 뚜렷하게 증상이 나타나지만, 더 고쳐지지 않음. 아래는 지금까지 써본 방법과 작동 결과를 담은 캡처본.
	- 현재 인코딩 euc-k로 변경
	- recvn() 사용(코드에 남겨둠)
	- retval을 누적해서 recv()가 종료되었을 때 메세지 출력
	- gpt 동원 -> 클라이언트의 recv()를 제안하는 방식대로 10번 정도 바꿨지만 안 됨.
	모든 방식에서 동일한 문제 발생
	![bug1-1](./img/bug2_debug1.png)
	![bug1-2](./img/bug2-2_debug1.png)
	![bug1-3](./img/bug2-3_debug1.png)
	![bug1-4](./img/bug2-4_debug1.png)
